# Pergunta Desconfortável 001

-   **Artigo original**: [Uncomfortable Question 001]()
-   **Tradução**: [Eric Douglas](https://github.com/ericdouglas)

## Questão

> **_O que você faria se encontrasse uma ferramenta com significativamente mais funcionalidades do que aquela que você já está confortável em trabalhar?_**

## Introdução

Essa série tem o objetivo de gerar conteúdo para provocar seu pensamento. A intenção não é fornecer uma abordagem ou ponto de vista correta/incorreta, mas sim oferecer uma pergunta desconfortável para que você tenha que realmente ir fundo na sua mente para entender o porquê de suas decisões, e quais as motivações por trás delas.

Outro objetivo é o de compartilhar conhecimento, experiências pessoais e descobertas, assim como recebê-las da comunidade, com a intenção de gerar um espaço saudável para discussão sobre as questões apresentadas.

## Contexto sobre a questão

No fim de 2017, descobri uma linguagem de programação chamada Elixir [1]. Fui contactado por uma empresa para uma vaga de desenvolvedor frontend, e olhando no blog deles, vi que eles adotaram Elixir como uma das principais ferramentas no desenvolvimento backend deles. Até esse ponto, eu nunca tinha ouvido falar de Elixir ou Erlang [2]. Como estava primariamente na comunidade JavaScript nesse ponto, isso nunca foi algo discutido na minha bolha.

Então eu comecei a ler os artigos no blog deles sobre Elixir e procurar quais funcionalidades tinha, e então eu descobri outra ferramenta: **Erlang**, e depois desse ponto, eu realmente comecei a entrar na toca do coelho 🐇 💊, e provavelmente sem retorno 😄.

Eu li diversos artigos [3] sobre Elixir e Erlang, e fiquei realmente maravilhado com os recursos robustos que a plataforma Erlang tinha.

> Obs: depois desse evento, eu comecei a buscar várias outras linguagens de programação para ser minha principal no desenvolvimento backend: Eu li sobre Go, Rust, Clojure, Haskell, mas a que me fisgou foi Elixir/Erlang, embora eu realmente queira aprender Rust no futuro.

Essa comparação [4] feita pelo Saša Jurić realmente atraiu minha atenção:

![Comparação Erlang](https://i.imgur.com/0mEzuSb.jpg)

> Essa tabela é do livro **Elixir in Action** do autor Saša Jurić.

⚠️ **Não entre nessa também** ⚠️

No mesmo tweet, tivemos algumas contestações válidas sobre a imagem anterior, com algumas igualmente válidas respostas do Saša. Gostaria de copiar tal conversação aqui uma vez que acredito que ela deve ser eternalizada por causa de seu conteído pragmático:

> _"Bom... não refaça o Redis, use o Postgres, e você ainda usaria upstart (isso simplesmente não chegará tão longe com tanta frequência)."_ - Jim Gray
>
> _"RabbitMQ também é bem útil se você está fazendo vários trabalhos em background (e é escrito em Erlang)"._ - Jim Gray
>
> _"Não refaça o nginx também, WTF, eu sei que Erlang é legal e tal mas não refaça coisas que já funcionam bem..."_ - Jim Gray
>
> _"Essa foto é uma história real, e o Erlang foi suficiente para as necessidades nesse caso."_ - Saša Jurić
>
> _"Eu nunca disse que ele é um substituto completo para todos os casos"_ - Saša Jurić
>
> ![Aviso sobre Erlang no livro Elixir in Action](https://i.imgur.com/Yc3BUow.jpg)
>
> _"Mas se suas necessidades são simples, o Erlang vai ser suficiente, fazendo a arquitetura geral ser mais simples"_ - Saša Jurić
>
> _"Essa é uma simples solução para um problema simples, e você sempre pode caminhar para outra solução depois quando tiver razões reais"_ - Saša Jurić

Erlang brings a lot of **power** and **minimalism** at the same time to developers, and let them deal
with tough topics, like _concurrency_, _error handling/fault-tolerance_, to name a few, in an
elegant way, through the _actor model_, _pattern matching_ and _supervision trees_, for example.

I remember to be really upset for being exposed to such tools "too late", and actually this is one of the reasons I'm writing this blog post: maybe I can be the one to at least inform another person that such technology exists and maybe it can change his/her plans, and consequentially change his/her life as it did with my own.

In 2017, I was in a moment trying to choose one side of the product development: although I love and would like to learn everything from Product Design to DevOps, I was trying to focus on one side. I had chosen frontend development initially, focused on SPA development with JavaScript, but after saw the Erlang platform, I stayed and I am still unable to forget it.

Even being proficient in JavaScript, so it would be really convenient for me to specialize only in Node.js, but I took the red pill and now I can't ignore the robustness that the Erlang platform has to offer. 30+ years of engineering focused on the building of a distributed, concurrent, and fault-tolerant platform is not something you can consciously throw away.

The impact of such discover changed my life, and now I feel that I truly found the path that aligns
deeply with me: a journey to become a specialist in distributed systems engineering, and teach it
to others in the most accessible, simple, and minimalist way.

## Resposta pessoal à questão

Try to avoid Hype Driven Development as much as possible, but never close your mind to new technologies. If you find something that has real advantages in relation to what you use now, do not stay in the comfort zone. Start a new journey and conquer this new world!

## Leituras recomendadas

If you are now interested in learning more about what made me change my career goals, and go towards the Erlang Ecosystem and distributed system engineering, I have some articles that I really encourage you to read, not for you to adopt Erlang, but to you have more information about what currently exists and in that way, you will be able to compare Erlang (and Elixir) with your current stack.

-   [First chapter of Elixir in Action](https://www.manning.com/books/elixir-in-action-second-edition)
    **obs**: you can read the first chapter for free
-   [Erlang and the Web](https://ninenines.eu/docs/en/cowboy/2.8/guide/erlang_web/)
-   [Why Elixir](https://www.theerlangelist.com/article/why_elixir) **obs**: read at least the Wrapping
    up section 😉

## Referências

1. [Elixir](https://elixir-lang.org/)
2. [Erlang](https://www.erlang.org/)
3. [dev-log elixir](https://github.com/ericdouglas/dev-log/blob/master/source/elixir.md) - obs: I
   actually consumed **much** more resources than what is registered there 😅
4. [Tweet from Elixir Tip: One of the best reasons to use Elixir/Erlang from Elixir in Action](https://twitter.com/ElixirTip/status/738794467264729088)
