# Pergunta Desconfortável 001

-   **Artigo original**: [Uncomfortable Question 001]()
-   **Tradução**: [Eric Douglas](https://github.com/ericdouglas)

```
tópicos: uncomfortable question
criado em: 2020-06-10
atualizado em: -
```

## Introdução

This new series in the blog has the goal to generate thought-provoking content. The intention is not to provide a correct/incorrect approach or point of view, but rather to offer an uncomfortable question so you need to really go deep in your mind to understand why you are making some decisions, and which are the motivations behind them.

Another goal is to share knowledge, personal experiences, and discoveries, as well as receiving them from the community, with the aim to generate a healthy space for discussion about the questions presented.

## Questão

> **_What would you do if you find a tool with significantly more features than the one you are
> already comfortable working with?_**

## Contexto sobre a questão

At the end of 2017, I discovered a programming language called Elixir [1]. I was contacted by a
company for a frontend developer position, and looking in their blog, I saw they adopted Elixir as one of the
core tools for their backend development. Until this point, I had never heard of it (Elixir) or Erlang [2].
Since I was mainly in the JavaScript community at that point, it was not something discussed in my bubble.

So I started to read their blog posts about Elixir and search which features it has, and I discovered
another tool: **Erlang**, and after this point, I truly started to enter the rabbit hole 🐇 💊, and
probably with no return 😄.

I read several articles [3] about Elixir and Erlang, and I was really amazed by how many robust features
the Erlang platform has.

> Obs: after that event, I started to search several other programming languages to be the main one for my backend
> development: I read about Go, Rust, Clojure, Haskell, but the one that catch me was Elixir/Erlang,
> although I truly want to play with Rust in the future.

This comparison [4] made by Saša Jurić really got my attention:

![Erlang comparison](https://github.com/ericdouglas/blog/blob/master/images/erlang-comparison.jpeg?raw=true)

> This table is from the book **Elixir in Action** from Saša Jurić.

⚠️ **Don't drink too much Kool-Aid** ⚠️

In the same tweet, we had some really valid contestations about the previous image, with some also valid answers from Saša as well. I would like to replicate such a conversation here since I do believe it should be eternalized due to its pragmatic content:

> _"Well...don't reroll Redis, use Postgres, and you'd still use upstart (it just won't get that far
> nearly as often)."_ - Jim Gray
>
> _"Also RabbitMQ is kinda handy if you're doing a lot of background jobs (which is written in
> Erlang)."_ - Jim Gray
>
> _"Also don't reroll nginx either, WTF, I know Erlang is cool and all but don't one-off stuff that
> already works well..."_ - Jim Gray
>
> _"That pic is a true story, and Erlang sufficed for the needs in that case."_ - Saša Jurić
>
> _"I never said it's a full-blown replacement for every case"_ - Saša Jurić
>
> ![Erlang disclaimer from the book Elixir in Action](https://github.com/ericdouglas/blog/blob/master/images/erlang-disclaimer.jpeg?raw=true)
>
> _"But if the needs are simpler, Erlang will suffice, making the overall arch simpler."_ - Saša Jurić
>
> _"That's a simple solution for a simple problem, and you can always step outside later when
> you have real reasons."_ - Saša Jurić

Erlang brings a lot of **power** and **minimalism** at the same time to developers, and let them deal
with tough topics, like _concurrency_, _error handling/fault-tolerance_, to name a few, in an
elegant way, through the _actor model_, _pattern matching_ and _supervision trees_, for example.

I remember to be really upset for being exposed to such tools "too late", and actually this is one of the reasons I'm writing this blog post: maybe I can be the one to at least inform another person that such technology exists and maybe it can change his/her plans, and consequentially change his/her life as it did with my own.

In 2017, I was in a moment trying to choose one side of the product development: although I love and would like to learn everything from Product Design to DevOps, I was trying to focus on one side. I had chosen frontend development initially, focused on SPA development with JavaScript, but after saw the Erlang platform, I stayed and I am still unable to forget it.

Even being proficient in JavaScript, so it would be really convenient for me to specialize only in Node.js, but I took the red pill and now I can't ignore the robustness that the Erlang platform has to offer. 30+ years of engineering focused on the building of a distributed, concurrent, and fault-tolerant platform is not something you can consciously throw away.

The impact of such discover changed my life, and now I feel that I truly found the path that aligns
deeply with me: a journey to become a specialist in distributed systems engineering, and teach it
to others in the most accessible, simple, and minimalist way.

## Resposta pessoal à questão

Try to avoid Hype Driven Development as much as possible, but never close your mind to new technologies. If you find something that has real advantages in relation to what you use now, do not stay in the comfort zone. Start a new journey and conquer this new world!

## Leituras recomendadas

If you are now interested in learning more about what made me change my career goals, and go towards the Erlang Ecosystem and distributed system engineering, I have some articles that I really encourage you to read, not for you to adopt Erlang, but to you have more information about what currently exists and in that way, you will be able to compare Erlang (and Elixir) with your current stack.

-   [First chapter of Elixir in Action](https://www.manning.com/books/elixir-in-action-second-edition)
    **obs**: you can read the first chapter for free
-   [Erlang and the Web](https://ninenines.eu/docs/en/cowboy/2.8/guide/erlang_web/)
-   [Why Elixir](https://www.theerlangelist.com/article/why_elixir) **obs**: read at least the Wrapping
    up section 😉

## Referências

1. [Elixir](https://elixir-lang.org/)
2. [Erlang](https://www.erlang.org/)
3. [dev-log elixir](https://github.com/ericdouglas/dev-log/blob/master/source/elixir.md) - obs: I
   actually consumed **much** more resources than what is registered there 😅
4. [Tweet from Elixir Tip: One of the best reasons to use Elixir/Erlang from Elixir in Action](https://twitter.com/ElixirTip/status/738794467264729088)
